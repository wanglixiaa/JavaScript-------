<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">
    <title>Document</title>
    <style>
      span{color:red;}
    </style>
</head>
<body>
  <h1>引用类型</h1>
  <h3>Object类型</h3>
  <p>我们看到的大多数引用类型值都是Object类型的实例</p>
  <p>创建Object实例的方式一：使用new操作符后跟Object构造函数；方式二：使用对象字面量表示法</p>
  <p>js可以使用方括号表示法来访问对象的属性</p>
  <p><span>**alert(person["name"])此处name是属性名，需要加双引号p85</span></p>
  <p><span>****var names="name" alert(person[names])此处names是变量名 可以通过变量来访问属性</span></p>
  <h3>Array类型</h3>
  <h4>检测数组</h4>
  <p>方法一：value instanceof Array(instance操作问题在于，它假定只有一个全局执行环境，若网页中包含多个框架，实际上就存在两个以上不同的全局执行环境)</p>
  <p>方法二：Array.isArray(value) (确定某个值到底是不是数组，而不用管它是在哪个全局执行环境中创建的</p>
  <h4>转换方法(不改变原数组)</h4>
  <p>toString() 返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串</p>
  <p>valueOf() 返回的还是数组</p>
  <p>toLocaleString() 调用的是每一项的toLocaleString()方法，尔不是toString()方法 </p>
  <p>join("||") 使用不同的分隔符来构建这个字符串，而不是默认的逗号</p>
  <h4>栈方法(后进先出)（改变了原数组）</h4>
  <p>push() 接受任意参数，将他们逐个添加到数组末尾，返回修改后数组的长度</p>
  <p>pop() 数组末尾移除最后一项，返回移除的项</p>
  <h4>队列方法(先进先出) （改变了原数组）</h4>
  <p>unshift() 在数组前端添加任意项并返回新数组的长度</p>
  <p>shift() 移除数组中的第一项并返回该项</p>
  <h4>重排序方法(改变了原数组)</h4>
  <p>reverse() 反转数组顺序</p>
  <p>sort() 按升序排列数组，会调用每项数组的toString()转型方法，然后比较得到字符串，以确定如何排序（15<5）sort()可接受一个比较函数作为参数，以便指定哪个值位于哪个值前面</p>
  <p>比较函数见p93</p>
  <h4>操作方法（concat()、slice()不改变原数组，splice改变原数组）</h4>
  <p>concat()基于当前数组中的所有项创建一个新数组，创建当前数组的副本，再将接受到的参数添加到这个副本的末尾，原数组不改变</p>
  <p>slice(开始索引*包括此项，结束索引*不包括此项) 基于当前数组中的一或多项创建一个新数组</p>
  <p>splice() 主要用途是向数组中部插入项</p><span>***改变了原数组</span>
  <p>删除：指定2个参数，删除的第一项的位置和要删除的项数</p>
  <p>插入、替换：向指定的位置插入任意数量的项，提供3个参数，起始位置、0（要删除的项数）、要插入的项 splice(2,0,"red","green") 会从当前数组的位置2开始，删除0项，插入“red"和“green"</p>
  <h4>位置方法，接受两个参数，查找的项和表示查找起点位置的索引（可选的），用全等===来查找的</h4>
  <p>indexOf()从数组的开头向后查找，没找到的情况下返回-1</p>
  <p>lastIndexOf()从数组的末尾向前查找，没找到的情况下返回-1</p>
  <h4>迭代方法(不会修改原数组)</h4>
  <p>定义了5个方法，每个方法接受两个参数：要在每一项上运行的函数和运行该函数的作用域对象-影响this的值（可选的参数）</p>
  <p>传入这5个方法中的函数接受3个参数：数组项的值、该项在数组中的位置、数组对象本身numbers.filter(function(item,index,array){return (item>2)})</p>
  <p>every(),对数组中的每一项运行给定函数，如果该函数对每一项都返回true则返回true</p><span>返回true/false</span>
  <p>filter()，对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组</p><span>返回数组</span>
  <p>forEach(),对数组中的每一项运行给定函数，这个方法没有返回值</p><span></span>
  <p>map()，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组</p><span>返回数组</span>
  <p>some(),对数组中的每一项运行给定函数，如果该函数对任一项返回true,则返回true</p><span>返回true/false</span>
  <h4>归并方法</h4>
  <li>reduce() 【1，2，3，4，5】1+2=3 3+3=6 6+4=10 10+5=15</li>
  <li>reduceRight()</li>
  <h3>Date类型</h3>
  <h4>继承的方法</h4>
  <p>valueOf()返回日期的毫秒表示，方便比较日期值</p>
  <h5>插花：人年轻的时候就开始认命了，觉得这辈子就这样了，那就不要埋怨日子不好过，没意思。我本是认命之人，感恩另一半拉我一把，告诉我生活可以是另一种努力、精彩的样子</h5>
  <h3>RegExp类型</h3>
  <p>JS通过此类型来支持正则表达式</p>
  <p>正则表达式：var expression=/pattern(模式)/flags(标志);</p>
  <p>模式部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定类、分组、向前查找、反向引用    </p>
  <p>模式有3个</p>
  <li>g：全局模式</li>
  <li>i:表示不区分大小写模式</li>
  <li>m:表示多行模式</li>
  <p>模式中使用的元字符都必须转义，正则中的元字符包括：( [ { \ ^ $ | ) ? * + . ] }</p>
  <p>字符串字面量形式来定义正则表达式：var aa=/[bc]at/i</p>
  <p>使用构造函数来创建正则表达式：var aa=new RegExp("[bc]at","i");</p>
  <h3>RegExp实例属性</h3>
  <li>global:true/false</li>
  <li>ignoreCase:true/false</li>
  <li>lastIndex:整数，表示开始搜索下一个匹配项的字符串位置，从0算起</li>
  <li>multiline:true/false</li>
  <li><span>source:正则表达式的字符串表示，两种模式的source属性是相同的，source属性保存的是规范形式的字符串，即字面量形式所用的字符串</span></li>
  <h3>RegExp实例方法</h3>
  <p><span>查看各元字符的表达意思<a href="http://www.runoob.com/regexp/regexp-metachar.html">http://www.runoob.com/regexp/regexp-metachar.html</a></span></p>

</body>
</html> 